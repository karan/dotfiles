/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Red Hat, Inc. All rights reserved.
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const jsonSchemaService_1 = require("vscode-json-languageservice/lib/umd/services/jsonSchemaService");
const nls = require("vscode-nls");
const strings_1 = require("../utils/strings");
const localize = nls.loadMessageBundle();
var MODIFICATION_ACTIONS;
(function (MODIFICATION_ACTIONS) {
    MODIFICATION_ACTIONS[MODIFICATION_ACTIONS["delete"] = 0] = "delete";
    MODIFICATION_ACTIONS[MODIFICATION_ACTIONS["add"] = 1] = "add";
})(MODIFICATION_ACTIONS = exports.MODIFICATION_ACTIONS || (exports.MODIFICATION_ACTIONS = {}));
class FilePatternAssociation {
    constructor(pattern) {
        try {
            this.patternRegExp = new RegExp(strings_1.convertSimple2RegExpPattern(pattern) + '$');
        }
        catch (e) {
            // invalid pattern
            this.patternRegExp = null;
        }
        this.schemas = [];
    }
    addSchema(id) {
        this.schemas.push(id);
    }
    matchesPattern(fileName) {
        return this.patternRegExp && this.patternRegExp.test(fileName);
    }
    getSchemas() {
        return this.schemas;
    }
}
exports.FilePatternAssociation = FilePatternAssociation;
class YAMLSchemaService extends jsonSchemaService_1.JSONSchemaService {
    constructor(requestService, contextService, promiseConstructor) {
        super(requestService, contextService, promiseConstructor);
        this.customSchemaProvider = undefined;
    }
    registerCustomSchemaProvider(customSchemaProvider) {
        this.customSchemaProvider = customSchemaProvider;
    }
    //tslint:disable
    resolveSchemaContent(schemaToResolve, schemaURL, dependencies) {
        let resolveErrors = schemaToResolve.errors.slice(0);
        let schema = schemaToResolve.schema;
        let contextService = this.contextService;
        let findSection = (schema, path) => {
            if (!path) {
                return schema;
            }
            let current = schema;
            if (path[0] === '/') {
                path = path.substr(1);
            }
            path.split('/').some((part) => {
                current = current[part];
                return !current;
            });
            return current;
        };
        let merge = (target, sourceRoot, sourceURI, path) => {
            let section = findSection(sourceRoot, path);
            if (section) {
                for (let key in section) {
                    if (section.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
                        target[key] = section[key];
                    }
                }
            }
            else {
                resolveErrors.push(localize('json.schema.invalidref', '$ref \'{0}\' in \'{1}\' can not be resolved.', path, sourceURI));
            }
        };
        let resolveExternalLink = (node, uri, linkPath, parentSchemaURL, parentSchemaDependencies) => {
            if (contextService && !/^\w+:\/\/.*/.test(uri)) {
                uri = contextService.resolveRelativePath(uri, parentSchemaURL);
            }
            uri = this.normalizeId(uri);
            const referencedHandle = this.getOrAddSchemaHandle(uri);
            return referencedHandle.getUnresolvedSchema().then(unresolvedSchema => {
                parentSchemaDependencies[uri] = true;
                if (unresolvedSchema.errors.length) {
                    let loc = linkPath ? uri + '#' + linkPath : uri;
                    resolveErrors.push(localize('json.schema.problemloadingref', 'Problems loading reference \'{0}\': {1}', loc, unresolvedSchema.errors[0]));
                }
                merge(node, unresolvedSchema.schema, uri, linkPath);
                return resolveRefs(node, unresolvedSchema.schema, uri, referencedHandle.dependencies);
            });
        };
        let resolveRefs = (node, parentSchema, parentSchemaURL, parentSchemaDependencies) => {
            if (!node || typeof node !== 'object') {
                return Promise.resolve(null);
            }
            let toWalk = [node];
            let seen = [];
            let openPromises = [];
            let collectEntries = (...entries) => {
                for (let entry of entries) {
                    if (typeof entry === 'object') {
                        toWalk.push(entry);
                    }
                }
            };
            let collectMapEntries = (...maps) => {
                for (let map of maps) {
                    if (typeof map === 'object') {
                        for (let key in map) {
                            let entry = map[key];
                            if (typeof entry === 'object') {
                                toWalk.push(entry);
                            }
                        }
                    }
                }
            };
            let collectArrayEntries = (...arrays) => {
                for (let array of arrays) {
                    if (Array.isArray(array)) {
                        for (let entry of array) {
                            if (typeof entry === 'object') {
                                toWalk.push(entry);
                            }
                        }
                    }
                }
            };
            let handleRef = (next) => {
                let seenRefs = [];
                while (next.$ref) {
                    const ref = next.$ref;
                    let segments = ref.split('#', 2);
                    delete next.$ref;
                    if (segments[0].length > 0) {
                        openPromises.push(resolveExternalLink(next, segments[0], segments[1], parentSchemaURL, parentSchemaDependencies));
                        return;
                    }
                    else {
                        if (seenRefs.indexOf(ref) === -1) {
                            merge(next, parentSchema, parentSchemaURL, segments[1]); // can set next.$ref again, use seenRefs to avoid circle
                            seenRefs.push(ref);
                        }
                    }
                }
                collectEntries(next.items, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else);
                collectMapEntries(next.definitions, next.properties, next.patternProperties, next.dependencies);
                collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.items, next.schemaSequence);
            };
            while (toWalk.length) {
                let next = toWalk.pop();
                if (seen.indexOf(next) >= 0) {
                    continue;
                }
                seen.push(next);
                handleRef(next);
            }
            return Promise.all(openPromises);
        };
        return resolveRefs(schema, schema, schemaURL, dependencies).then(_ => new jsonSchemaService_1.ResolvedSchema(schema, resolveErrors));
    }
    //tslint:enable
    getSchemaForResource(resource, doc = undefined) {
        const resolveSchema = () => {
            const seen = Object.create(null);
            const schemas = [];
            for (const entry of this.filePatternAssociations) {
                if (entry.matchesPattern(resource)) {
                    for (const schemaId of entry.getSchemas()) {
                        if (!seen[schemaId]) {
                            schemas.push(schemaId);
                            seen[schemaId] = true;
                        }
                    }
                }
            }
            if (schemas.length > 0) {
                return super.createCombinedSchema(resource, schemas).getResolvedSchema().then(schema => {
                    if (schema.schema && schema.schema.schemaSequence && schema.schema.schemaSequence[doc.currentDocIndex]) {
                        return new jsonSchemaService_1.ResolvedSchema(schema.schema.schemaSequence[doc.currentDocIndex]);
                    }
                    return schema;
                });
            }
            return Promise.resolve(null);
        };
        if (this.customSchemaProvider) {
            return this.customSchemaProvider(resource)
                .then(schemaUri => {
                if (Array.isArray(schemaUri)) {
                    if (schemaUri.length === 0) {
                        return resolveSchema();
                    }
                    return Promise.all(schemaUri.map(schemaUri => this.resolveCustomSchema(schemaUri, doc))).then(schemas => ({
                        'errors': [],
                        'schema': {
                            'anyOf': schemas.map(schemaObj => schemaObj.schema)
                        }
                    }), err => resolveSchema());
                }
                if (!schemaUri) {
                    return resolveSchema();
                }
                return this.resolveCustomSchema(schemaUri, doc);
            })
                .then(schema => schema, err => resolveSchema());
        }
        else {
            return resolveSchema();
        }
    }
    resolveCustomSchema(schemaUri, doc) {
        return __awaiter(this, void 0, void 0, function* () {
            const unresolvedSchema = yield this.loadSchema(schemaUri);
            const schema = yield this.resolveSchemaContent(unresolvedSchema, schemaUri, []);
            if (schema.schema && schema.schema.schemaSequence && schema.schema.schemaSequence[doc.currentDocIndex]) {
                return new jsonSchemaService_1.ResolvedSchema(schema.schema.schemaSequence[doc.currentDocIndex]);
            }
            return schema;
        });
    }
    /**
     * Save a schema with schema ID and schema content.
     * Overrides previous schemas set for that schema ID.
     */
    saveSchema(schemaId, schemaContent) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = this.normalizeId(schemaId);
            this.getOrAddSchemaHandle(id, schemaContent);
            return Promise.resolve(undefined);
        });
    }
    /**
     * Delete a schema with schema ID.
     */
    deleteSchema(schemaId) {
        return __awaiter(this, void 0, void 0, function* () {
            const id = this.normalizeId(schemaId);
            if (this.schemasById[id]) {
                delete this.schemasById[id];
            }
            return Promise.resolve(undefined);
        });
    }
    /**
     * Add content to a specified schema at a specified path
     */
    addContent(additions) {
        return __awaiter(this, void 0, void 0, function* () {
            const schema = yield this.getResolvedSchema(additions.schema);
            if (schema) {
                const resolvedSchemaLocation = this.resolveJSONSchemaToSection(schema.schema, additions.path);
                if (typeof resolvedSchemaLocation === 'object') {
                    resolvedSchemaLocation[additions.key] = additions.content;
                }
                yield this.saveSchema(additions.schema, schema.schema);
            }
        });
    }
    /**
     * Delete content in a specified schema at a specified path
     */
    deleteContent(deletions) {
        return __awaiter(this, void 0, void 0, function* () {
            const schema = yield this.getResolvedSchema(deletions.schema);
            if (schema) {
                const resolvedSchemaLocation = this.resolveJSONSchemaToSection(schema.schema, deletions.path);
                if (typeof resolvedSchemaLocation === 'object') {
                    delete resolvedSchemaLocation[deletions.key];
                }
                yield this.saveSchema(deletions.schema, schema.schema);
            }
        });
    }
    /**
     * Take a JSON Schema and the path that you would like to get to
     * @returns the JSON Schema resolved at that specific path
     */
    resolveJSONSchemaToSection(schema, paths) {
        const splitPathway = paths.split('/');
        let resolvedSchemaLocation = schema;
        for (const path of splitPathway) {
            if (path === '') {
                continue;
            }
            this.resolveNext(resolvedSchemaLocation, path);
            resolvedSchemaLocation = resolvedSchemaLocation[path];
        }
        return resolvedSchemaLocation;
    }
    /**
     * Resolve the next Object if they have compatible types
     * @param object a location in the JSON Schema
     * @param token the next token that you want to search for
     */
    // tslint:disable-next-line: no-any
    resolveNext(object, token) {
        // tslint:disable-next-line: no-any
        if (Array.isArray(object) && isNaN(token)) {
            throw new Error('Expected a number after the array object');
        }
        else if (typeof object === 'object' && typeof token !== 'string') {
            throw new Error('Expected a string after the object');
        }
    }
    /**
     * Everything below here is needed because we're importing from vscode-json-languageservice umd and we need
     * to provide a wrapper around the javascript methods we are calling since they have no type
     */
    normalizeId(id) {
        return super.normalizeId(id);
    }
    getOrAddSchemaHandle(id, unresolvedSchemaContent) {
        return super.getOrAddSchemaHandle(id, unresolvedSchemaContent);
    }
    // tslint:disable-next-line: no-any
    loadSchema(schemaUri) {
        return super.loadSchema(schemaUri);
    }
    registerExternalSchema(uri, filePatterns, unresolvedSchema) {
        return super.registerExternalSchema(uri, filePatterns, unresolvedSchema);
    }
    clearExternalSchemas() {
        super.clearExternalSchemas();
    }
    setSchemaContributions(schemaContributions) {
        super.setSchemaContributions(schemaContributions);
    }
    getRegisteredSchemaIds(filter) {
        return super.getRegisteredSchemaIds(filter);
    }
    getResolvedSchema(schemaId) {
        return super.getResolvedSchema(schemaId);
    }
    onResourceChange(uri) {
        return super.onResourceChange(uri);
    }
}
exports.YAMLSchemaService = YAMLSchemaService;
//# sourceMappingURL=yamlSchemaService.js.map